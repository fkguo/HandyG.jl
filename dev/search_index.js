var documenterSearchIndex = {"docs":
[{"location":"man/installation/#Installation","page":"Installation","title":"Installation","text":"HandyG.jl is a Julia wrapper around a shared library libhandyg built from the upstream Fortran project.","category":"section"},{"location":"man/installation/#Install-the-Julia-package","page":"Installation","title":"Install the Julia package","text":"From a Git repository (GitHub/GitLab/…):\n\njulia> ]\npkg> add https://github.com/fkguo/HandyG.jl\n\nor:\n\nusing Pkg\nPkg.add(url=\"https://github.com/fkguo/HandyG.jl.git\")","category":"section"},{"location":"man/installation/#Runtime-library:-HandyG_jll","page":"Installation","title":"Runtime library: HandyG_jll","text":"HandyG.jl depends on HandyG_jll, which provides prebuilt libhandyg binaries for the supported platforms. End users do not need a local Fortran toolchain.\n\nIn most cases, installing HandyG.jl is sufficient. If you want to install the JLL explicitly:\n\nusing Pkg\nPkg.add(\"HandyG_jll\")","category":"section"},{"location":"man/installation/#Build-the-docs-locally","page":"Installation","title":"Build the docs locally","text":"julia --project=docs -e 'using Pkg; Pkg.develop(PackageSpec(path=pwd())); Pkg.instantiate(); include(\"docs/make.jl\")'","category":"section"},{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#HandyG.libhandyg_path","page":"API Reference","title":"HandyG.libhandyg_path","text":"libhandyg_path() -> String\n\nReturn the filesystem path of the libhandyg shared library (provided by HandyG_jll).\n\n\n\n\n\n","category":"function"},{"location":"api/#HandyG.HandyG","page":"API Reference","title":"HandyG.HandyG","text":"HandyG\n\nJulia bindings for the Fortran library handyG.\n\nThe main entrypoints are:\n\nG, G!: scalar evaluation in superflat / flat / condensed form\nG_batch!: batch evaluation for large workloads (fixed-depth column-major matrices)\ninum: i0± prescription inputs (structure-of-arrays, allocation-free hot paths)\n\nSee docs/src/ for the user manual.\n\n\n\n\n\n","category":"module"},{"location":"api/#HandyG.INum","page":"API Reference","title":"HandyG.INum","text":"INum{T<:Real}\n\nScalar value with an explicit i0± prescription (upstream handyG inum).\n\nFields:\n\nc::Complex{T}: complex value\ni0::Int8: +1 or -1\n\nConstruct with inum.\n\n\n\n\n\n","category":"type"},{"location":"api/#HandyG.INumMat","page":"API Reference","title":"HandyG.INumMat","text":"INumMat{T}\n\nStructure-of-arrays (SoA) representation of a matrix of inum values, intended for batch calls.\n\nFields:\n\nc: StridedMatrix{Complex{T}}\ni0: StridedMatrix{Int8}\n\nConstruct with inum.\n\n\n\n\n\n","category":"type"},{"location":"api/#HandyG.INumVec","page":"API Reference","title":"HandyG.INumVec","text":"INumVec{T}\n\nStructure-of-arrays (SoA) representation of a vector of inum values.\n\nFields:\n\nc: StridedVector{Complex{T}}\ni0: StridedVector{Int8}\n\nConstruct with inum.\n\n\n\n\n\n","category":"type"},{"location":"api/#HandyG.G!-Tuple{Ref{ComplexF64}, AbstractVector{<:Integer}, StridedVector{Float64}, Union{Real, ComplexF64}}","page":"API Reference","title":"HandyG.G!","text":"G!(out::Ref{ComplexF64}, m::AbstractVector{<:Integer}, z, y) -> out\n\nConvenience overload for condensed form that accepts any integer element type for m.\n\nThis method converts m to the C-ABI element type (Cint) using an internal thread-local scratch buffer. It may allocate only when the scratch buffer grows. For allocation-free hot paths, pass m::Vector{Cint}.\n\n\n\n\n\n","category":"method"},{"location":"api/#HandyG.G!-Tuple{Ref{ComplexF64}, StridedVector{Float64}}","page":"API Reference","title":"HandyG.G!","text":"G!(out::Ref{ComplexF64}, args...) -> out\nG!(out::StridedVector{ComplexF64}, args...) -> out\n\nIn-place evaluation.\n\nIf out is a Ref{ComplexF64}, evaluates a single GPL and writes to out[].\nIf out is a vector, dispatches to G_batch! for batched evaluation.\n\n\n\n\n\n","category":"method"},{"location":"api/#HandyG.G-Tuple{AbstractVector{<:Integer}, StridedVector{Float64}, Union{Real, ComplexF64}}","page":"API Reference","title":"HandyG.G","text":"G(m::AbstractVector{<:Integer}, z, y) -> ComplexF64\n\nConvenience overload for condensed form that accepts any integer element type for m.\n\nThis method converts m to the C-ABI element type (Cint) using an internal thread-local scratch buffer. It may allocate only when the scratch buffer grows. For allocation-free hot paths, pass m::Vector{Cint}.\n\n\n\n\n\n","category":"method"},{"location":"api/#HandyG.G-Tuple{StridedVector{Float64}}","page":"API Reference","title":"HandyG.G","text":"G(g::StridedVector{Float64}) -> ComplexF64\nG(g::StridedVector{ComplexF64}) -> ComplexF64\nG(z::StridedVector, y) -> ComplexF64\nG(m::StridedVector{Cint}, z::StridedVector, y) -> ComplexF64\nG(z::INumVec, y::INum) -> ComplexF64\nG(m::StridedVector{Cint}, z::INumVec, y::INum) -> ComplexF64\n\nEvaluate a generalized polylogarithm using handyG.\n\nDispatch selects one of the upstream calling conventions:\n\nsuperflat: G(g) where g = [z..., y]\nflat: G(z, y)\ncondensed: G(m, z, y)\n\nFor explicit i0± prescriptions, use inum inputs.\n\n\n\n\n\n","category":"method"},{"location":"api/#HandyG.G_batch!-Tuple{StridedVector{ComplexF64}, StridedMatrix{Float64}, AbstractVector{<:Integer}}","page":"API Reference","title":"HandyG.G_batch!","text":"G_batch!(out, args..., len::AbstractVector{<:Integer}) -> out\n\nConvenience overloads that accept any integer element type for len (and m in condensed form).\n\nFor len, these methods convert to Cint using an internal thread-local scratch buffer and may allocate only when the scratch buffer grows. For condensed batch m, a Matrix{Cint} is allocated for ABI compatibility.\n\nFor allocation-free hot paths, pass len::Vector{Cint} and (if applicable) m::Matrix{Cint}.\n\n\n\n\n\n","category":"method"},{"location":"api/#HandyG.G_batch!-Tuple{StridedVector{ComplexF64}, StridedMatrix{Float64}, StridedVector{Int32}}","page":"API Reference","title":"HandyG.G_batch!","text":"G_batch!(out, g, len) -> out\nG_batch!(out, z, y, len) -> out\nG_batch!(out, m, z, y, len) -> out\n\nBatched evaluation for many independent GPL calls.\n\nBatch inputs use fixed-depth column-major matrices (depth_max, N) and a len::Vector{Cint} giving the active length of each column. Results are written to out::Vector{ComplexF64} of length N.\n\n\n\n\n\n","category":"method"},{"location":"api/#HandyG.clearcache!-Tuple{}","page":"API Reference","title":"HandyG.clearcache!","text":"clearcache!()\nclearcache()\n\nClear handyG's internal caches.\n\nThe upstream authors recommend calling this between phase-space points in Monte Carlo workloads.\n\n\n\n\n\n","category":"method"},{"location":"api/#HandyG.inum-Union{Tuple{Complex{T}}, Tuple{T}, Tuple{Complex{T}, Integer}} where T<:Real","page":"API Reference","title":"HandyG.inum","text":"inum(z::Complex{T}, i0::Integer=+1) where {T<:Real} -> INum{T}\ninum(x::T, i0::Integer=+1) where {T<:Real} -> INum{T}\ninum(c::StridedVector{Complex{T}}, i0::StridedVector{Int8}) where {T<:Real} -> INumVec{T}\ninum(c::StridedMatrix{Complex{T}}, i0::StridedMatrix{Int8}) where {T<:Real} -> INumMat{T}\n\nCreate i0±-aware inputs (upstream handyG inum).\n\ni0 should be Int8(+1) or Int8(-1). For complex values with non-zero imaginary part, upstream handyG treats the sign of imag(z) as the prescription regardless of i0.\n\n\n\n\n\n","category":"method"},{"location":"api/#HandyG.inum-Union{Tuple{T}, Tuple{Union{DenseArray{Complex{T}, 1}, Base.ReinterpretArray{Complex{T}, 1, S, A, IsReshaped} where {A<:Union{SubArray{T, N, A, I, true} where {T, N, A<:DenseArray, I<:Union{Tuple{Vararg{Real}}, Tuple{AbstractUnitRange, Vararg{Any}}}}, DenseArray}, IsReshaped, S}, Base.ReshapedArray{Complex{T}, 1, A} where A<:Union{Base.ReinterpretArray{T, N, S, A, IsReshaped} where {T, N, A<:Union{SubArray{T, N, A, I, true} where {T, N, A<:DenseArray, I<:Union{Tuple{Vararg{Real}}, Tuple{AbstractUnitRange, Vararg{Any}}}}, DenseArray}, IsReshaped, S}, SubArray{T, N, A, I, true} where {T, N, A<:DenseArray, I<:Union{Tuple{Vararg{Real}}, Tuple{AbstractUnitRange, Vararg{Any}}}}, DenseArray}, SubArray{Complex{T}, 1, A, I} where {A<:Union{Base.ReinterpretArray{T, N, S, A, IsReshaped} where {T, N, A<:Union{SubArray{T, N, A, I, true} where {T, N, A<:DenseArray, I<:Union{Tuple{Vararg{Real}}, Tuple{AbstractUnitRange, Vararg{Any}}}}, DenseArray}, IsReshaped, S}, Base.ReshapedArray{T, N, A} where {T, N, A<:Union{Base.ReinterpretArray{T, N, S, A, IsReshaped} where {T, N, A<:Union{SubArray{T, N, A, I, true} where {T, N, A<:DenseArray, I<:Union{Tuple{Vararg{Real}}, Tuple{AbstractUnitRange, Vararg{Any}}}}, DenseArray}, IsReshaped, S}, SubArray{T, N, A, I, true} where {T, N, A<:DenseArray, I<:Union{Tuple{Vararg{Real}}, Tuple{AbstractUnitRange, Vararg{Any}}}}, DenseArray}}, DenseArray}, I<:Tuple{Vararg{Union{Base.AbstractCartesianIndex, AbstractRange{<:Union{Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8}}, Base.ReshapedArray{T, N, A, Tuple{}} where {T, N, A<:AbstractUnitRange}, Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8}}}}}, AbstractVector{<:Integer}}} where T<:Real","page":"API Reference","title":"HandyG.inum","text":"inum(c::StridedVector{Complex{T}}, i0::AbstractVector{<:Integer}) where {T<:Real} -> INumVec{T}\n\nConvenience overload accepting any integer element type for i0.\n\nThis allocates a temporary Vector{Int8}. For allocation-free hot paths, pass i0::Vector{Int8}.\n\n\n\n\n\n","category":"method"},{"location":"api/#HandyG.inum-Union{Tuple{T}, Tuple{Union{DenseArray{Complex{T}, 2}, Base.ReinterpretArray{Complex{T}, 2, S, A, IsReshaped} where {A<:Union{SubArray{T, N, A, I, true} where {T, N, A<:DenseArray, I<:Union{Tuple{Vararg{Real}}, Tuple{AbstractUnitRange, Vararg{Any}}}}, DenseArray}, IsReshaped, S}, Base.ReshapedArray{Complex{T}, 2, A} where A<:Union{Base.ReinterpretArray{T, N, S, A, IsReshaped} where {T, N, A<:Union{SubArray{T, N, A, I, true} where {T, N, A<:DenseArray, I<:Union{Tuple{Vararg{Real}}, Tuple{AbstractUnitRange, Vararg{Any}}}}, DenseArray}, IsReshaped, S}, SubArray{T, N, A, I, true} where {T, N, A<:DenseArray, I<:Union{Tuple{Vararg{Real}}, Tuple{AbstractUnitRange, Vararg{Any}}}}, DenseArray}, SubArray{Complex{T}, 2, A, I} where {A<:Union{Base.ReinterpretArray{T, N, S, A, IsReshaped} where {T, N, A<:Union{SubArray{T, N, A, I, true} where {T, N, A<:DenseArray, I<:Union{Tuple{Vararg{Real}}, Tuple{AbstractUnitRange, Vararg{Any}}}}, DenseArray}, IsReshaped, S}, Base.ReshapedArray{T, N, A} where {T, N, A<:Union{Base.ReinterpretArray{T, N, S, A, IsReshaped} where {T, N, A<:Union{SubArray{T, N, A, I, true} where {T, N, A<:DenseArray, I<:Union{Tuple{Vararg{Real}}, Tuple{AbstractUnitRange, Vararg{Any}}}}, DenseArray}, IsReshaped, S}, SubArray{T, N, A, I, true} where {T, N, A<:DenseArray, I<:Union{Tuple{Vararg{Real}}, Tuple{AbstractUnitRange, Vararg{Any}}}}, DenseArray}}, DenseArray}, I<:Tuple{Vararg{Union{Base.AbstractCartesianIndex, AbstractRange{<:Union{Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8}}, Base.ReshapedArray{T, N, A, Tuple{}} where {T, N, A<:AbstractUnitRange}, Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8}}}}}, AbstractMatrix{<:Integer}}} where T<:Real","page":"API Reference","title":"HandyG.inum","text":"inum(c::StridedMatrix{Complex{T}}, i0::AbstractMatrix{<:Integer}) where {T<:Real} -> INumMat{T}\n\nConvenience overload accepting any integer element type for i0.\n\nThis allocates a temporary Matrix{Int8}. For allocation-free hot paths, pass i0::Matrix{Int8}.\n\n\n\n\n\n","category":"method"},{"location":"api/#HandyG.set_hoelder_circle!-Tuple{Float64}","page":"API Reference","title":"HandyG.set_hoelder_circle!","text":"set_hoelder_circle!(x::Float64)\n\nSet the H&ouml;lder circle size (hCircle in the upstream API).\n\n\n\n\n\n","category":"method"},{"location":"api/#HandyG.set_lidelta!-Tuple{Float64}","page":"API Reference","title":"HandyG.set_lidelta!","text":"set_lidelta!(x::Float64)\n\nSet the polylog series truncation threshold (Lidel in the upstream API).\n\n\n\n\n\n","category":"method"},{"location":"api/#HandyG.set_mpldelta!-Tuple{Float64}","page":"API Reference","title":"HandyG.set_mpldelta!","text":"set_mpldelta!(x::Float64)\n\nSet the MPL truncation threshold (MPLdel in the upstream API).\n\n\n\n\n\n","category":"method"},{"location":"api/#HandyG.set_options!-Tuple{}","page":"API Reference","title":"HandyG.set_options!","text":"set_options!(; mpldelta=nothing, lidelta=nothing, hoelder_circle=nothing)\n\nConvenience wrapper to set multiple runtime options at once.\n\n\n\n\n\n","category":"method"},{"location":"man/i0/#i0-Prescription","page":"i0 Prescription","title":"i0± Prescription","text":"Upstream handyG supports explicit i0± prescriptions via the inum datatype. In HandyG.jl, the allocation-free representation is structure-of-arrays (SoA):\n\nComplex values in one array\nInt8 i0 values in a parallel array (+1 or -1)\n\nNote: upstream handyG only uses i0± for real values on branch cuts. For complex numbers with non-zero imaginary part, the sign of imag(z) determines the side automatically.","category":"section"},{"location":"man/i0/#Scalar-inum","page":"i0 Prescription","title":"Scalar inum","text":"using HandyG\n\ny = inum(1/0.3 + 0im, +1)","category":"section"},{"location":"man/i0/#Vector-inum","page":"i0 Prescription","title":"Vector inum","text":"z = ComplexF64[1, 0, 5]\nz_i0 = Int8[+1, +1, +1]\nz_inum = inum(z, z_i0)\n\nFor convenience you may pass other integer element types for i0 (e.g. Vector{Int}); HandyG.jl will allocate a temporary Vector{Int8}. For allocation-free hot paths, prefer Int8[...].","category":"section"},{"location":"man/i0/#Matrix-inum-(for-batch-calls)","page":"i0 Prescription","title":"Matrix inum (for batch calls)","text":"depth_max = 4\nN = 10\n\nz = zeros(ComplexF64, depth_max, N)\nz_i0 = fill(Int8(+1), depth_max, N)\n\nz_inum = inum(z, z_i0)  # INumMat","category":"section"},{"location":"man/i0/#Flat-form-with-explicit-i0","page":"i0 Prescription","title":"Flat form with explicit i0","text":"using HandyG\n\nx = 0.3\nz = ComplexF64[1, 0, 5]\ny = ComplexF64(1/x, 0)\n\nz_inum = inum(z, Int8[+1, +1, +1])\ny_inum = inum(y, +1)\n\nres = G(z_inum, y_inum)","category":"section"},{"location":"man/i0/#Condensed-form-with-explicit-i0","page":"i0 Prescription","title":"Condensed form with explicit i0","text":"m = Cint[1, 2]\nz = ComplexF64[1, 5]\nz_inum = inum(z, Int8[-1, +1])\ny_inum = inum(ComplexF64(1/0.3, 0), +1)\n\nres = G(m, z_inum, y_inum)","category":"section"},{"location":"man/i0/#Batch-with-explicit-i0","page":"i0 Prescription","title":"Batch with explicit i0","text":"Flat batch:\n\nout = Vector{ComplexF64}(undef, N)\nlen = fill(Cint(3), N)\n\ny = fill(ComplexF64(0.3, 0.0), N)\ny_i0 = fill(Int8(+1), N)\n\nG_batch!(out, z_inum, inum(y, y_i0), len)","category":"section"},{"location":"man/calling/#Calling-Conventions","page":"Calling Conventions","title":"Calling Conventions","text":"Upstream handyG exposes G(...) in multiple “shapes” (superflat / flat / condensed). HandyG.jl keeps the same ideas, implemented via Julia multiple dispatch.\n\nAll APIs below are double precision currently (Float64 / ComplexF64).\n\nInputs should be Float64 / ComplexF64 arrays for performance and to avoid implicit conversions.","category":"section"},{"location":"man/calling/#Superflat-form","page":"Calling Conventions","title":"Superflat form","text":"The last entry is y, the previous entries are z₁, …, zₙ:\n\nusing HandyG\n\ng = [1.0, 0.0, 0.5, 0.3]  # z..., y\nval = G(g)","category":"section"},{"location":"man/calling/#Flat-form","page":"Calling Conventions","title":"Flat form","text":"z = [1.0, 0.0, 0.5]\ny = 0.3\nval = G(z, y)\n\nComplex inputs:\n\nz = ComplexF64[1, 0, 0.5, 1im]\ny = ComplexF64(0.3, 0.0)\nval = G(z, y)","category":"section"},{"location":"man/calling/#Condensed-form","page":"Calling Conventions","title":"Condensed form","text":"In condensed form, m encodes runs of trailing zeros. (See the upstream paper/README for the definition; this wrapper follows the upstream semantics.)\n\nm = Cint[1, 2]\nz = [1.0, 0.5]\ny = 0.3\nval = G(m, z, y)\n\nFor convenience you may also pass m::Vector{Int} (or other integer types); HandyG.jl converts to the C-ABI element type (Cint) using an internal scratch buffer. After warmup, this can be allocation-free; see Manual → Performance Notes.","category":"section"},{"location":"man/calling/#In-place-scalar-evaluation:-G!","page":"Calling Conventions","title":"In-place scalar evaluation: G!","text":"For tight loops, write into a preallocated Ref{ComplexF64}:\n\nout = Ref{ComplexF64}()\nG!(out, [1.0, 0.0, 0.5, 0.3])\nval = out[]\n\nFor batch evaluation, see Manual → Batch API.","category":"section"},{"location":"man/calling/#Fortran-examples-Julia-equivalents","page":"Calling Conventions","title":"Fortran examples → Julia equivalents","text":"The upstream README contains a small Fortran example program. Here are direct Julia equivalents:\n\nusing HandyG\n\nx = 0.3\n\n# flat form with integers (use Float64 in Julia)\nres1 = G([1.0, 2.0, 1.0])\n\n# very flat (superflat) form\nres2 = G([1.0, 0.0, 0.5, x])\n\n# same as flat form\nres2b = G([1.0, 0.0, 0.5], x)\n\n# condensed form\nres2c = G(Cint[1, 2], [1.0, 0.5], x)","category":"section"},{"location":"man/options/#Runtime-Options-and-Cache","page":"Runtime Options","title":"Runtime Options and Cache","text":"Upstream handyG exposes runtime options and a cyclic cache. HandyG.jl forwards a small subset needed for typical workflows.","category":"section"},{"location":"man/options/#Clear-cache","page":"Runtime Options","title":"Clear cache","text":"handyG caches intermediate results internally. The authors recommend clearing the cache between phase-space points in Monte Carlo workflows.\n\nusing HandyG\n\nclearcache!()\n\nclearcache() is an alias for clearcache!().","category":"section"},{"location":"man/options/#Set-runtime-options","page":"Runtime Options","title":"Set runtime options","text":"using HandyG\n\nset_options!(mpldelta=1e-15, lidelta=1e-15, hoelder_circle=1.1)\n\nYou can also set them individually:\n\nset_mpldelta!(1e-15)\nset_lidelta!(1e-15)\nset_hoelder_circle!(1.1)","category":"section"},{"location":"man/performance/#Performance-Notes","page":"Performance Notes","title":"Performance Notes","text":"","category":"section"},{"location":"man/performance/#Allocation-free-hot-paths","page":"Performance Notes","title":"Allocation-free hot paths","text":"After Julia compilation warmup, the following are designed to run without heap allocations:\n\nG(...) scalar calls\nG!(out, ...) scalar calls into a preallocated Ref{ComplexF64}\nG_batch!(out, ...) batched calls into a preallocated output vector\n\nFor high-throughput use, prefer G_batch! and reuse all buffers.","category":"section"},{"location":"man/performance/#Recommended-default:-non-Cint-integers-with-zero-allocations-(after-warmup)","page":"Performance Notes","title":"Recommended default: non-Cint integers with zero allocations (after warmup)","text":"The C ABI expects m/len as Cint (Int32) for correctness. For convenience, HandyG.jl accepts Vector{Int} (or other integer types) and converts them internally.\n\nTo keep this conversion allocation-free in steady state:\n\nMake the integer arrays persistent (e.g. const globals or reused buffers)\nCall the relevant function once during initialization to let internal scratch buffers size\n\nExample (condensed form):\n\nusing HandyG\n\nconst m = [1, 2]               # Vector{Int}\nconst z = [1.0, 0.5]\nconst y = 0.3\n\n# warmup (compiles + sizes internal scratch)\nG(m, z, y)\n\n# steady-state: no allocations from the `m` conversion\n@assert (@allocated G(m, z, y)) == 0\n\nExample (batch len):\n\nusing HandyG\n\nconst len = [4, 3]   # Vector{Int}\n\n# warmup\nout = Vector{ComplexF64}(undef, 2)\ng = zeros(Float64, 4, 2)\nG_batch!(out, g, len)\n\n# steady-state\n@assert (@allocated G_batch!(out, g, len)) == 0\n\nNotes:\n\nIf the internal scratch buffer needs to grow (e.g. you later pass a longer m/len), a one-time allocation can occur at that moment. Pre-warm with the maximum expected length to avoid this.\nFor absolute clarity and predictability in tight loops, passing Cint[...] / Vector{Cint} is still the “gold standard”, but the above pattern is a good default for ergonomic code.","category":"section"},{"location":"man/performance/#Alternative-(fastest):-preconvert-once-to-Cint","page":"Performance Notes","title":"Alternative (fastest): preconvert once to Cint","text":"If m/len are reused many times and rarely change, the lowest-overhead approach is to convert them once up front and then call the Cint methods directly:\n\nusing HandyG\n\nconst m_int = [1, 2]\nconst m = Cint.(m_int)  # one-time allocation\n\nval = G(m, [1.0, 0.5], 0.3)\n\nThis avoids the per-call conversion work entirely.","category":"section"},{"location":"man/performance/#Input-layout","page":"Performance Notes","title":"Input layout","text":"For batch calls, use fixed-depth (depth_max, N) matrices with a len::Vector{Cint} per column.\n\nThis avoids:\n\nper-call allocations\nragged array overhead\npointer chasing and cache misses from “array of vectors”","category":"section"},{"location":"man/performance/#Parallelism","page":"Performance Notes","title":"Parallelism","text":"The underlying Fortran library maintains global runtime options and caches. This generally implies the library is not re-entrant under Julia threads.\n\nRecommended strategies:\n\nUse G_batch! to maximize single-call throughput.\nFor true parallel scaling, prefer multi-process parallelism (Distributed), where each process has its own libhandyg state.","category":"section"},{"location":"#HandyG.jl","page":"Home","title":"HandyG.jl","text":"Julia bindings for the Fortran library handyG (rapid numerical evaluation of generalized polylogarithms / GPLs).\n\nThis documentation focuses on:\n\nA Julia API that stays close to the upstream Fortran calling conventions\nAllocation-free hot paths (G, G!, G_batch!) after warmup\nCross-platform binaries via HandyG_jll (BinaryBuilder/Yggdrasil)","category":"section"},{"location":"#Where-to-start","page":"Home","title":"Where to start","text":"Installation: see Manual → Installation\nCalling conventions: see Manual → Calling Conventions\ni0± prescription: see Manual → i0 Prescription\nBatch API for large workloads: see Manual → Batch API\nFull API reference: see API Reference","category":"section"},{"location":"#Quick-start","page":"Home","title":"Quick start","text":"using HandyG\n\n# superflat form (z..., y)\nval = G([1.0, 0.0, 0.5, 0.3])","category":"section"},{"location":"literature/#References","page":"References","title":"References","text":"","category":"section"},{"location":"literature/#Upstream-project","page":"References","title":"Upstream project","text":"handyG repository: https://gitlab.com/mule-tools/handyg","category":"section"},{"location":"literature/#Primary-reference","page":"References","title":"Primary reference","text":"L. Naterop, A. Signer, Y. Ulrich, handyG — rapid numerical evaluation of generalised polylogarithms (arXiv:1909.01656): https://arxiv.org/abs/1909.01656","category":"section"},{"location":"man/batch/#Batch-API","page":"Batch API","title":"Batch API","text":"For large workloads, G_batch! evaluates many GPLs in one call without allocating.\n\nThis wrapper uses fixed-depth column-major matrices:\n\nInputs are (depth_max, N) matrices (Julia is column-major)\nA len::Vector{Cint} tells how many entries are valid in each column\nResults are written into out::Vector{ComplexF64} of length N\n\nlen must be Vector{Cint} for allocation-free hot paths. For convenience you may pass other integer element types (e.g. Vector{Int}); HandyG.jl converts to Cint using an internal scratch buffer. After warmup, this can be allocation-free; see Manual → Performance Notes.","category":"section"},{"location":"man/batch/#Superflat-batch","page":"Batch API","title":"Superflat batch","text":"using HandyG\n\ndepth_max = 4\nN = 2\n\ng = zeros(Float64, depth_max, N)\nlen = Cint[4, 3]\n\ng[:, 1] = [1.0, 0.0, 0.5, 0.3]   # z..., y\ng[1:3, 2] = [1.0, 2.0, 1.0]      # z..., y (len=3)\n\nout = Vector{ComplexF64}(undef, N)\nG_batch!(out, g, len)","category":"section"},{"location":"man/batch/#Flat-batch","page":"Batch API","title":"Flat batch","text":"using HandyG\n\ndepth_max = 3\nN = 2\n\nz = zeros(Float64, depth_max, N)\nlen = Cint[3, 2]\nz[:, 1] = [1.0, 0.0, 0.5]\nz[1:2, 2] = [1.0, 2.0]\n\ny = ComplexF64[0.3 + 0im, 1.0 + 0im]\nout = Vector{ComplexF64}(undef, N)\n\nG_batch!(out, z, y, len)","category":"section"},{"location":"man/batch/#Notes","page":"Batch API","title":"Notes","text":"Inputs must be contiguous column-major (stride-1 first dimension, contiguous columns). Views like @view may fail the checks unless they are contiguous.\nG_batch! is the preferred interface for throughput and to avoid per-call overhead.","category":"section"}]
}
