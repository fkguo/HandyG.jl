# `i0±` Prescription

Upstream handyG supports explicit `i0±` prescriptions via the `inum` datatype. In `HandyG.jl`, the allocation-free representation is **structure-of-arrays** (SoA):

- `Complex` values in one array
- `Int8` `i0` values in a parallel array (`+1` or `-1`)

Note: upstream handyG only uses `i0±` for real values on branch cuts. For complex numbers with non-zero imaginary part, the sign of `imag(z)` determines the side automatically.

## Scalar `inum`

```julia
using HandyG

y = inum(1/0.3 + 0im, +1)
```

## Vector `inum`

```julia
z = ComplexF64[1, 0, 5]
z_i0 = Int8[+1, +1, +1]
z_inum = inum(z, z_i0)
```

For convenience you may pass other integer element types for `i0` (e.g. `Vector{Int}`); `HandyG.jl` will allocate a temporary `Vector{Int8}`. For allocation-free hot paths, prefer `Int8[...]`.

## Matrix `inum` (for batch calls)

```julia
depth_max = 4
N = 10

z = zeros(ComplexF64, depth_max, N)
z_i0 = fill(Int8(+1), depth_max, N)

z_inum = inum(z, z_i0)  # INumMat
```

## Flat form with explicit `i0`

```julia
using HandyG

x = 0.3
z = ComplexF64[1, 0, 5]
y = ComplexF64(1/x, 0)

z_inum = inum(z, Int8[+1, +1, +1])
y_inum = inum(y, +1)

res = G(z_inum, y_inum)
```

## Condensed form with explicit `i0`

```julia
m = Cint[1, 2]
z = ComplexF64[1, 5]
z_inum = inum(z, Int8[-1, +1])
y_inum = inum(ComplexF64(1/0.3, 0), +1)

res = G(m, z_inum, y_inum)
```

## Batch with explicit `i0`

Flat batch:

```julia
out = Vector{ComplexF64}(undef, N)
len = fill(Cint(3), N)

y = fill(ComplexF64(0.3, 0.0), N)
y_i0 = fill(Int8(+1), N)

G_batch!(out, z_inum, inum(y, y_i0), len)
```
